#!/bin/sh
# decrypt_keyfile. Getting a key from a file for an encrypted volume.
#
# Copyright (c) 2025 Semyon A Mironov
#
# Authors: Semyon A Mironov <s.mironov@mgmsam.pro>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

CRYPTSETUP_DIR="/run/cryptsetup"

cryptsetup_message () {
    local IFS=' '
    if test -x /bin/plymouth && plymouth --ping
    then
        plymouth message --text="cryptsetup: $*"
    elif test ${#*} -lt 70
    then
        echo "cryptsetup: $*" >&2
    else
        # use busybox's fold(1) and sed(1) at initramfs stage
        echo "cryptsetup: $*" | fold -s | sed '1! s/^/    /' >&2
    fi
    return 0
}

shutdown_system () {
    sleep 5
    cryptsetup_message "ERROR: $CRYPTTAB_NAME: The system is shutting down"
    sleep 5
    poweroff -f
}

test "$CRYPTTAB_OPTION_tries" -le 0 || {
    CRYPTSETUP_TRIED="$CRYPTSETUP_DIR/cryptsetup-$CRYPTTAB_NAME.tried"
    test -d "$CRYPTSETUP_DIR" || mkdir -p "$CRYPTSETUP_DIR"
    if test -f "$CRYPTSETUP_TRIED"
    then
        . "$CRYPTSETUP_TRIED"
    fi
    TRIED=$((TRIED + 1))
    echo "TRIED=$TRIED" > "$CRYPTSETUP_TRIED"
    echo >&2

    test "$TRIED" -le "$CRYPTTAB_OPTION_tries" ||
        shutdown_system
}

is_timeout () {
    case "${1:-}" in
        0)
            ;;
        *[0-9][smhd] )
            case "${1%?}" in
                *[!0-9]*)
                    false
                    ;;
            esac
            ;;
        *[!0-9]*)
            false
            ;;
    esac || {
        cryptsetup_message "ERROR: $CRYPTTAB_NAME: Couldn't resolve timeout '$1'"
        return 1
    }
}

# resolve_device(DEV)
#   Resolve device node from a name. This expands any LABEL or UUID.
#   $1=name
#   Resolved name is echoed.
resolve_device () {
    case "$DEV" in
        UUID=* | LABEL=* | PARTUUID=* | PARTLABEL=*)
            DEV="$(blkid --list-one --match-token "$DEV" --output device)" || DEV=
        ;;
    esac
    test -b "${DEV:-}" || return 1
}

read_key () {
    test -e "$1" || {
        cryptsetup_message "ERROR: $CRYPTTAB_NAME: Key not found: '$1'"
        return 1
    }

    test -z "${CRYPTTAB_OPTION_keyfile_size:-}" ||
        OPTIONS="bs=$CRYPTTAB_OPTION_keyfile_size count=1"

    test -z "${CRYPTTAB_OPTION_keyfile_offset:-}" ||
        OPTIONS="${OPTIONS:-} skip=$CRYPTTAB_OPTION_keyfile_offset"

    dd if="$1" ${OPTIONS:-} status=none 2>/dev/null ||
        cryptsetup_message "ERROR: $CRYPTTAB_NAME: Can't read key '$1'"
}

get_key () {
    # $1 - DEV:KEY:TIMEOUT
    # $1 - DEV:TIMEOUT
    # $1 - DEV:KEY
    # $1 - DEV
    # $1 - KEY:TIMEOUT
    # $1 - TIMEOUT
    # $1 - KEY

    IFS=: read DEV KEY TIMEOUT <<EOF
$1
EOF
    printf '%s\n' "dev[$DEV]" "key[$KEY]" "timout[$TIMEOUT]" >&2

    if resolve_device
    then
        if test "${TIMEOUT:-}"
        then
            is_timeout "$TIMEOUT" || return
        else
            if test "${KEY:-}"
            then
                if is_timeout "$KEY"
                then
                    TIMEOUT="$KEY"
                    KEY=
                fi
            fi
        fi
        # result: DEV:KEY:TIMEOUT or DEV:TIMEOUT or DEV:KEY or DEV
    else
        test "${DEV:-}" || {
            cryptsetup_message "ERROR: $CRYPTTAB_NAME: Couldn't resolve device '$DEV'"
            return
        }
        if test "${TIMEOUT:-}"
        then
            cryptsetup_message "ERROR: $CRYPTTAB_NAME: Couldn't resolve device '$DEV'"
            return
        fi
        if test "${KEY:-}"
        then
            is_timeout "$KEY" || return
            TIMEOUT="$KEY"
            KEY="$DEV"
            DEV=
        else
            if is_timeout "$DEV"
            then
                TIMEOUT="$DEV"
                DEV=
                # result: TIMEOUT
                return
            else
                KEY="$DEV"
                DEV=
            fi
        fi
        # result: KEY:TIMEOUT or KEY
    fi

    printf '%s\n' "dev[$DEV]" "key[$KEY]" "timout[$TIMEOUT]" >&2

    if test "${DEV:+"${KEY}"}"
    then
        # result: DEV:KEY:TIMEOUT or DEV:KEY
        DEV_MOUNT="$CRYPTSETUP_DIR/${CRYPTTAB_NAME}_decryptor"

        test -d "$DEV_MOUNT" || {
            test ! -e "$DEV_MOUNT" && mkdir -p "$DEV_MOUNT" 2>/dev/null
        } && mount "$DEV" "$DEV_MOUNT" 2>/dev/null || {
            cryptsetup_message "ERROR: $CRYPTTAB_NAME: Can't attach decryptor in '$DEV_MOUNT'"
            sleep 5
            return
        }

        read_key "$DEV_MOUNT/$KEY" && {
            umount "$DEV_MOUNT" 2>/dev/null || :
            exit
        } || {
            umount "$DEV_MOUNT" 2>/dev/null
        }
    else
        # result: DEV:TIMEOUT or DEV or KEY:TIMEOUT or KEY
        read_key "${DEV:-"$KEY"}"
    fi
}

run_askpass () {
    case "${TIMEOUT:-}" in
        "")
            /lib/cryptsetup/askpass "Please unlock disk $CRYPTTAB_NAME: "
            ;;
        *)
            timeout -s KILL "$TIMEOUT" \
            /lib/cryptsetup/askpass "Please unlock disk $CRYPTTAB_NAME: " || {
                cryptsetup_message "ERROR: $CRYPTTAB_NAME: Password timeout expired"
                shutdown_system
            }
    esac
}

case "${1:-}" in
    "" | none | -)
        ;;
    *)
        sleep 3
        get_key "$1" || :
        ;;
esac

# Please comment out this line if you don't want to ask for a password
run_askpass

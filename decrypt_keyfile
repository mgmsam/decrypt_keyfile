#!/bin/sh
# decrypt_keyfile. Getting a key from a file for an encrypted volume.
#
# Copyright (c) 2025 Semyon A Mironov
#
# Authors: Semyon A Mironov <s.mironov@mgmsam.pro>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

CRYPTSETUP_DIR="/run/cryptsetup"
TIMEOUT=

cryptsetup_message () {
    local IFS=' '
    if test -x /bin/plymouth && plymouth --ping
    then
        plymouth message --text="cryptsetup: $*"
    elif test ${#*} -lt 70
    then
        echo "cryptsetup: $*" >&2
    else
        # use busybox's fold(1) and sed(1) at initramfs stage
        echo "cryptsetup: $*" | fold -s | sed '1! s/^/    /' >&2
    fi
    return 0
}

shutdown_system () {
    sleep 5
    cryptsetup_message "ERROR: $CRYPTTAB_NAME: The system is shutting down"
    sleep 5
    poweroff -f
}

test "${CRYPTTAB_OPTION_tries:-0}" -le 0 || {
    CRYPTSETUP_TRIED="$CRYPTSETUP_DIR/cryptsetup-$CRYPTTAB_NAME.tried"
    test -d "$CRYPTSETUP_DIR" || mkdir -p "$CRYPTSETUP_DIR"
    if test -f "$CRYPTSETUP_TRIED"
    then
        . "$CRYPTSETUP_TRIED"
    fi
    TRIED=$((TRIED + 1))
    echo "TRIED=$TRIED" > "$CRYPTSETUP_TRIED"
    echo >&2

    test "$TRIED" -le "$CRYPTTAB_OPTION_tries" ||
        shutdown_system
}

convert_timeout_to_second () {
    case "$2" in
        s) TIMEOUT="$1" ;;
        m) TIMEOUT="$(($1 * 60))" ;;
        h) TIMEOUT="$(($1 * 60 * 60))" ;;
        d) TIMEOUT="$(($1 * 24 * 60 * 60))" ;;
    esac
}

resolve_timeout () {
    case "${1:-}" in
        [0-] | none | infinity)
            TIMEOUT=
            ;;
        *[0-9][smhd])
            case "${1%?}" in
                *[!0-9]*)
                    return 1
                    ;;
            esac
            convert_timeout_to_second "${1%?}" "${1#"${1%?}"}"
            ;;
        *[!0-9]*)
            return 1
            ;;
        *)
            TIMEOUT="$1"
            ;;
    esac
}

# resolve_decryptor(DEV|KEY)
#   Resolve device node or key file from a name. This expands any LABEL or UUID.
#   $1=name
#   Resolved name is echoed.
resolve_decryptor () {
    DECRYPTOR="${DEV:-}"
    DECRYPTOR_IS_FILE=no
    SEC=0
    while test "$SEC" -le "${DECRYPTOR_TIMEOUT:-"$SEC"}"
    do
        test "${DECRYPTOR_IS_FILE:-}" = no &&
        case "${DECRYPTOR:-}" in
            UUID=* | LABEL=* | PARTUUID=* | PARTLABEL=*)
                if DEV="$(blkid --list-one --match-token "$DECRYPTOR" --output device)"
                then
                    DECRYPTOR="$DEV"
                    return
                fi ;;
            "" | - | none)
                test "${KEY:-}" || return
                DECRYPTOR="$KEY" KEY=
                DECRYPTOR_IS_FILE=yes
                false ;;
            *)
                false ;;
        esac || if test -e "$DECRYPTOR"
        then
            return
        fi
        SEC="$((SEC + 1))"
        sleep 1
    done 2>/dev/null
    return 1
}

mount_dev () {
    DEV_MOUNT="$CRYPTSETUP_DIR/${CRYPTTAB_NAME}_decryptor"
    test -d "$DEV_MOUNT" || {
        test ! -e "$DEV_MOUNT" && mkdir -p "$DEV_MOUNT" 2>/dev/null
    } && mount "$DEV" "$DEV_MOUNT" 2>/dev/null || {
        cryptsetup_message "ERROR: $CRYPTTAB_NAME: Can't attach decryptor in '$DEV_MOUNT'"
        sleep 5
        return 1
    }
}

read_key () {
    test -z "${CRYPTTAB_OPTION_keyfile_size:-}" ||
        OPTIONS="bs=$CRYPTTAB_OPTION_keyfile_size count=1"

    test -z "${CRYPTTAB_OPTION_keyfile_offset:-}" ||
        OPTIONS="${OPTIONS:-} skip=$CRYPTTAB_OPTION_keyfile_offset"

    dd if="$1" ${OPTIONS:-} status=none 2>/dev/null || {
        cryptsetup_message "ERROR: $CRYPTTAB_NAME: Can't read '$1'"
        return 1
    }
}

get_key () {
    IFS=: read DEV KEY TIMEOUT <<EOF
$1
EOF
    if test "${TIMEOUT:-}"
    then
        resolve_timeout "$TIMEOUT" || {
            cryptsetup_message "ERROR: $CRYPTTAB_NAME: Couldn't resolve timeout '$TIMEOUT'"
            TIMEOUT=
        }
    elif test "${KEY:-}"
    then
        if resolve_timeout "$KEY"
        then
            KEY=
        fi
    elif resolve_timeout "$DEV"
    then
        return
    fi

    case "${TIMEOUT:-}" in
        infinity)
            PASSWORD_TIMEOUT=infinity
            DECRYPTOR_TIMEOUT= ;;
        "")
            PASSWORD_TIMEOUT=infinity
            DECRYPTOR_TIMEOUT=5 ;;
        *)
            PASSWORD_TIMEOUT="$TIMEOUT"
            DECRYPTOR_TIMEOUT="$TIMEOUT" ;;
    esac

    case "${KEY:-}" in
        - | none) KEY= ;;
    esac

    resolve_decryptor || return

    if test "${KEY:-}"
    then
        test -b "$DECRYPTOR" || {
            cryptsetup_message "ERROR: $CRYPTTAB_NAME: is not a block device: '$DECRYPTOR'"
            return
        }
        mount_dev && read_key "$DEV_MOUNT/$KEY" && {
            umount "$DEV_MOUNT" 2>/dev/null || :
            exit
        } || umount "$DEV_MOUNT" 2>/dev/null
    elif test -d "$DECRYPTOR"
    then
        cryptsetup_message "ERROR: $CRYPTTAB_NAME: is directory: '$DECRYPTOR'"
    else
        read_key "$DECRYPTOR" && exit
    fi
}

run_askpass () {
    case "${PASSWORD_TIMEOUT:-"${TIMEOUT:-}"}" in
        infinity)
            /lib/cryptsetup/askpass "Please unlock disk $CRYPTTAB_NAME: "
            ;;
        *)
            timeout -s KILL "$TIMEOUT" \
            /lib/cryptsetup/askpass "Please unlock disk $CRYPTTAB_NAME: " || {
                cryptsetup_message "ERROR: $CRYPTTAB_NAME: Password timeout expired"
                shutdown_system
            }
    esac
}

get_key "${1:-none}" || :
run_askpass
